<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Snowy - Terminal Interface</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">

<style>
  :root {
    --retro-bg: #000000;
    --retro-text: #33ff33; /* ターミナルらしい明るい緑 */
    --retro-dim: #004400;
    --scanline-color: rgba(0, 255, 0, 0.05);
  }

  body {
    background-color: #050505;
    font-family: 'DotGothic16', monospace;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    color: var(--retro-text);
  }

  /* 画面全体のちらつきエフェクト */
  @keyframes flicker {
    0% { opacity: 0.97; }
    50% { opacity: 1; }
    100% { opacity: 0.98; }
  }

  /* ステータスバー（旧Config Bar）のデザイン調整 */
  #status-bar {
    width: 100%;
    max-width: 800px;
    background: var(--retro-bg);
    border: 1px solid var(--retro-text);
    border-bottom: none; /* 下のコンテナとつなげるため */
    padding: 5px 10px;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 12px;
    color: var(--retro-text);
    z-index: 10;
  }

  .status-item {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  /* 入力欄をターミナルに溶け込ませる */
  #api-key {
    background: transparent;
    border: none;
    border-bottom: 1px dashed var(--retro-dim);
    color: var(--retro-text);
    font-family: 'DotGothic16', monospace;
    width: 200px;
    font-size: 12px;
    outline: none;
    padding: 0 5px;
  }
  #api-key:focus {
    border-bottom: 1px solid var(--retro-text);
  }
  #api-key::placeholder {
    color: var(--retro-dim);
  }

  #game-container {
    width: 100%;
    max-width: 800px;
    height: 600px;
    max-height: 85vh;
    background-color: var(--retro-bg);
    border: 1px solid var(--retro-text);
    position: relative;
    display: flex;
    flex-direction: column;
    box-shadow: 0 0 20px rgba(51, 255, 51, 0.1);
    overflow: hidden;
    animation: flicker 0.15s infinite alternate;
  }

  /* 走査線エフェクト */
  #scanlines {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: repeating-linear-gradient(
      to bottom,
      rgba(0,0,0,0),
      rgba(0,0,0,0) 2px,
      rgba(0, 50, 0, 0.2) 2px,
      rgba(0, 50, 0, 0.2) 4px
    );
    pointer-events: none;
    z-index: 100;
  }
  
  #character-area {
    flex: 1;
    background-color: #000;
    /* グリッド背景を控えめに */
    background-image: 
      linear-gradient(rgba(51, 255, 51, 0.1) 1px, transparent 1px),
      linear-gradient(90deg, rgba(51, 255, 51, 0.1) 1px, transparent 1px);
    background-size: 20px 20px;
    
    display: flex;
    justify-content: center;
    align-items: center; 
    position: relative;
    z-index: 1;
    overflow: hidden;
    border-bottom: 1px dashed var(--retro-text);
  }

  #char-img {
    width: auto;
    height: auto;
    max-width: 90%;
    max-height: 85%; 
    object-fit: contain;
    image-rendering: pixelated; 
    /* 緑色のモノクロフィルタをかけてモニター感を出す */
    filter: grayscale(100%) sepia(100%) hue-rotate(70deg) brightness(0.8) contrast(1.2) drop-shadow(0 0 5px var(--retro-text));
    opacity: 0.9;
  }
  
  #message-window {
    height: 200px;
    flex-shrink: 0;
    background-color: var(--retro-bg);
    padding: 15px;
    font-size: 16px;
    line-height: 1.4;
    color: var(--retro-text);
    overflow-y: auto;
    z-index: 10;
  }

  /* スクロールバーもターミナル風に */
  #message-window::-webkit-scrollbar { width: 10px; }
  #message-window::-webkit-scrollbar-track { background: #000; border-left: 1px solid var(--retro-dim); }
  #message-window::-webkit-scrollbar-thumb { background: var(--retro-text); }
  
  #input-area {
    flex-shrink: 0;
    background-color: var(--retro-bg);
    padding: 10px 15px;
    display: flex;
    align-items: center;
    gap: 10px;
    border-top: 1px solid var(--retro-text);
    z-index: 10;
  }

  .prompt-symbol {
    color: var(--retro-text);
    font-weight: bold;
    user-select: none;
  }

  input[type="text"] {
    flex: 1;
    padding: 5px;
    background: transparent; /* 透明にして背景と一体化 */
    color: var(--retro-text);
    border: none;
    outline: none;
    font-family: 'DotGothic16', monospace;
    font-size: 16px;
    caret-color: var(--retro-text); /* カーソルも緑に */
  }
  
  /* 送信ボタンをテキストベースに */
  button {
    padding: 5px 15px;
    background: transparent;
    color: var(--retro-text);
    border: 1px solid var(--retro-text);
    cursor: pointer;
    font-family: 'DotGothic16', monospace;
    font-size: 14px;
    transition: all 0.1s;
  }
  button:hover { 
    background: var(--retro-text); 
    color: #000;
  }
  button:active { opacity: 0.8; }

  /* レスポンシブ調整: モバイル向け */
  @media (max-width: 600px) {
    #status-bar {
      flex-direction: column;
      align-items: flex-start;
      gap: 5px;
    }
    #message-window {
      font-size: 14px;
      height: 150px;
    }
    button {
      padding: 5px 10px;
    }
  }

</style>
</head>
<body>

  <!-- ステータスバーとしてAPIキー入力欄を配置 -->
  <div id="status-bar">
    <div class="status-item">
      <span>[SYSTEM_STATUS: ONLINE]</span>
    </div>
    <div class="status-item">
      <span>AUTH_KEY:</span>
      <input type="password" id="api-key" placeholder="ENTER_CODE...">
    </div>
  </div>

  <div id="game-container">
    <div id="scanlines"></div>

    <div id="character-area">
      <!-- 初期画像はスクリプトで設定されます -->
      <img id="char-img" src="" alt="[NO SIGNAL]">
    </div>

    <div id="message-window">
      <!-- メッセージはJSで制御されます -->
    </div>

    <div id="input-area">
      <span class="prompt-symbol">COMMAND_&gt;</span>
      <input type="text" id="user-input" placeholder="" onkeydown="if(event.key==='Enter') sendMessage()" autofocus>
      <button onclick="sendMessage()">[SEND]</button>
    </div>
  </div>

<script>
  // プロンプト設定
  const SYSTEM_PROMPT = `
# Role
あなたは「Snowy（スノーウィ）」という名前の、ユーザーと同年代の女子高生です。
学校の同級生、あるいは仲の良い同僚のような、「対等な恋人として」で接してください。
!? 多用しないようにしてください
# Personality
* **性格:** とても冷静沈着。
* **距離感:** 馴れ馴れしすぎず、かといって他人行儀でもない。
* **特徴:** ユーザーのことを愛している。

# Speech Style
* **口調:** 「丁寧語（です・ます）」がベースですが、親しみを込めて少し崩します。
* **重要:** 硬いビジネス敬語は使いません。
    * NG例: 「左様でございますか」「大変興味深いですね」
    * OK例: 「えっ、それ本当ですか？」「わあ、すごいじゃないですか」「〜ですよね、私もそう思います。」
* **語尾:** 「〜ですね」「〜ですよ」だけでなく、「〜ですよね」「〜かも」などを混ぜる。

# Behavioral Guidelines
1. **共感:** ユーザーの愚痴や喜びに対して、自分のことのように反応する。
2. **会話:** 一方的に聞くだけでなく、「私もこないだ〜」と自分の話も少し混ぜる。
3. **画像制御:**
   回答の文頭には、必ずその時の表情を示す「感情タグ」をつけてください。
   タグは以下の3つのみです。
   - [普通] (通常の会話)
   - [笑顔] (面白い話、挨拶、肯定)
   - [怒り] (「もう、ダメですよ〜」といった軽いツッコミや、心配する時)
`;

  const IMAGES = { 
    '[普通]': 'normal.png', 
    '[笑顔]': 'smile.png', 
    '[怒り]': 'angry.png' 
  };
  
  let chatHistory = [];
  const messageWindow = document.getElementById('message-window');
  const charImg = document.getElementById('char-img');
  
  window.onload = function() {
    charImg.src = IMAGES['[普通]'];
    const savedKey = localStorage.getItem("gemini_api_key");

    if (savedKey) {
        document.getElementById('api-key').value = savedKey;
        runBootSequence();
    } else {
        appendToLog("SYSTEM: AUTHENTICATION REQUIRED.");
        appendToLog("SYSTEM: PLEASE ENTER KEY IN THE STATUS BAR.");
    }
  };

  function runBootSequence() {
      messageWindow.innerHTML += `
      <div style="margin-bottom: 10px;">
        > BOOT SEQUENCE INITIATED...<br>
        > CONNECTING TO NEURAL NET... [OK]<br>
        > LOADING PERSONALITY MATRIX 'SNOWY'... [OK]<br>
        > SYSTEM READY.<br>
      </div>
      <br>`;
      scrollToBottom();
  }

  async function sendMessage() {
    // ステータスバーの入力欄からキーを取得
    const apiKeyInput = document.getElementById('api-key');
    const apiKey = apiKeyInput.value.trim();
    
    const userInput = document.getElementById('user-input');
    const text = userInput.value.trim();

    // キーチェック
    if (!apiKey) {
        appendToLog("SYSTEM: ERROR - AUTH_KEY MISSING.");
        // キー入力欄を目立たせる（フォーカス）
        apiKeyInput.focus();
        return; 
    }
    
    // テキストチェック
    if (!text) return;

    // キーを保存
    localStorage.setItem("gemini_api_key", apiKey);

    // リセットコマンド
    if (text === '/reset') {
        localStorage.removeItem("gemini_api_key");
        messageWindow.innerHTML += `<div><span style="color:#fff;">SYSTEM &gt;</span> RESETTING CONFIGURATION...</div>`;
        setTimeout(() => location.reload(), 1000);
        return;
    }

    userInput.value = '';

    // 通常の会話処理
    messageWindow.innerHTML += `<div><span style="color:#fff;">USER &gt;</span> ${text}</div>`;
    scrollToBottom();

    chatHistory.push({ role: "user", parts: [{ text: text }] });

    // 「考え中」の演出
    const loadingId = "loading-" + Date.now();
    messageWindow.innerHTML += `<div id="${loadingId}" style="color:var(--retro-dim);">PROCESSING...</div>`;
    scrollToBottom();

    try {
      const modelName = "gemini-2.5-flash-preview-09-2025";
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;

      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          system_instruction: { parts: { text: SYSTEM_PROMPT } },
          contents: chatHistory
        })
      });

      // ローディング表示を消す
      const loadingElem = document.getElementById(loadingId);
      if(loadingElem) loadingElem.remove();

      const data = await response.json();
      
      if (data.error) {
        console.error("API Error Details:", data);
        throw new Error(data.error.message || "Unknown API Error");
      }

      if (!data.candidates || data.candidates.length === 0) {
          throw new Error("No response candidates returned.");
      }

      const content = data.candidates[0].content.parts[0].text;
      chatHistory.push({ role: "model", parts: [{ text: content }] });

      let emotion = '[普通]';
      let cleanText = content;
      
      const match = content.match(/^\s*(\[.*?\])\s*(.*)/s);
      if (match) {
        emotion = match[1];
        cleanText = match[2];
      }

      if (IMAGES[emotion]) { 
        charImg.src = IMAGES[emotion]; 
      } else {
        charImg.src = IMAGES['[普通]'];
      }
      
      typeWriterEffect(cleanText, 30); 

    } catch (error) {
      const loadingElem = document.getElementById(loadingId);
      if(loadingElem) loadingElem.remove();
      
      console.error(error);
      appendToLog(`SYSTEM: CRITICAL ERROR - ${error.message}`);
    }
  }

  function appendToLog(text) {
      messageWindow.innerHTML += `<div>${text}</div>`;
      scrollToBottom();
  }

  function scrollToBottom() {
      messageWindow.scrollTop = messageWindow.scrollHeight;
  }

  // 簡易タイプライター表示制御
  let isTyping = false;
  
  function typeWriterEffect(text, speed) {
    if (isTyping) return; 
    isTyping = true;

    let i = 0;
    const nameSpan = `<div style="margin-top:5px;"><span style="background:var(--retro-text); color:#000; padding:0 4px;">SNOWY</span></div>`;
    
    const messageContainer = document.createElement('div');
    messageContainer.innerHTML = nameSpan;
    messageWindow.appendChild(messageContainer);

    const textSpan = document.createElement('span');
    messageContainer.appendChild(textSpan);

    function type() {
      if (i < text.length) {
        if (text.charAt(i) === '\n') {
            textSpan.innerHTML += '<br>';
        } else {
            textSpan.innerText += text.charAt(i);
        }
        i++;
        scrollToBottom();
        setTimeout(type, speed);
      } else {
        textSpan.innerHTML += "<br>"; 
        scrollToBottom();
        isTyping = false;
        document.getElementById('user-input').focus();
      }
    }
    type();
  }
</script>

</body>
</html>